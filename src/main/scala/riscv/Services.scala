package riscv

import spinal.core._
import spinal.lib._

trait MemoryService {
  /**
    * Returns the Pipeline's instruction bus.
    */
  def getExternalIBus: MemBus

  /**
    * Returns the Pipeline's data bus.
    */
  def getExternalDBus: MemBus

  /**
    * Creates a new instruction bus to be used in stage.
    */
  def createInternalIBus(stage: Stage): MemBus

  /**
    * Creates a new data bus to be used in stage.
    */
  def createInternalDBus(stage: Stage): MemBus

  /**
   * Return all stages that have an internal DBUS. I.e., the stages that are
   * able to put requests on the DBUS.
   */
  def getDBusStages: Seq[Stage]

  type MemBusFilter = (Stage, MemBus, MemBus) => Unit

  /**
    * The `filter` function is called on every created data bus. The passed
    * arguments are 1) the stage in which the data bus is created, 2) the data
    * bus that is used in this stage, and 2) the data bus that will be connected
    * to the external data bus. When `filter` is called, the two data buses are
    * disconnected. The `filter` function is called in the context of the
    * top-level Pipeline component.
    */
  def filterDBus(filter: MemBusFilter): Unit

  type MemBusObserver = (Stage, MemBus) => Unit

  /**
    * The `observer` function is called on every created data bus. The passed
    * arguments are 1) the stage in which the data bus is created, and 2) the
    * data bus that is used in this stage. The `observer` function is called in
    * the context of the top-level Pipeline component.
    */
  def observeDBus(observer: MemBusObserver): Unit
}

trait FetchAddressTranslator {
  /**
   * This method can be used to change the address used to fetch instructions.
   * The input address is the one calculated by the IF stage (i.e., the one
   * generated by software) and the return value will be put on the IBUS. If
   * necessary, the pipeline can be stalled from this method using the stage's
   * arbitration. This method is called in the context of the given stage.
   */
  def translate(stage: Stage, address: UInt): UInt
}

trait FetchService {
  def setAddressTranslator(translator: FetchAddressTranslator): Unit
}

trait DecoderService {
  type Action = Map[PipelineData[_ <: Data], Data]

  trait DecoderConfig {
    def addDecoding(opcode: MaskedLiteral,
                    itype: InstructionType,
                    action: Action): Unit
    def addDecoding(opcode: MaskedLiteral, action: Action): Unit
    def addDefault(action: Action): Unit
    def addDefault(data: PipelineData[_ <: Data], value: Data): Unit
  }

  protected val decoderConfig: DecoderConfig
  protected def stage: Stage

  def configure(f: DecoderConfig => Unit): Unit = {
    stage.rework(f(decoderConfig))
  }

  def getSupportedOpcodes: Iterable[MaskedLiteral]
}

trait IssueService {
  def setDestination(opcode: MaskedLiteral, stage: Stage): Unit = {
    setDestinations(opcode, Set(stage))
  }

  def setDestinations(opcode: MaskedLiteral, stages: Set[Stage]): Unit
}

trait IntAluService {
  object AluOp extends SpinalEnum {
    val ADD, SUB, SLT, SLTU, XOR, OR, AND, SRC2 = newElement()
  }

  object Src1Select extends SpinalEnum {
    val RS1, PC = newElement()
  }

  object Src2Select extends SpinalEnum {
    val RS2, IMM = newElement()
  }

  def addOperation(opcode: MaskedLiteral,
                   op: SpinalEnumElement[AluOp.type],
                   src1: SpinalEnumElement[Src1Select.type],
                   src2: SpinalEnumElement[Src2Select.type]): Unit

  def resultData: PipelineData[UInt]
}

object LsuOperationType extends SpinalEnum {
  val NONE, LOAD, STORE = newElement()
}

object LsuAccessWidth extends SpinalEnum {
  val B, H, W = newElement()
}

trait LsuAddressTranslator {
  /**
   * This method can be used to change the address used by the LSU. The input
   * address is the one calculated by the LSU (i.e., the one generated by
   * software) and the return value will be used by the LSU. If the operation is
   * NONE, it means the the current instruction is not an LSU operation. If
   * necessary, the pipeline can be stalled from this method using the stage's
   * arbitration. This method is called in the context of the given stage.
   */
  def translate(stage: Stage,
                address: UInt,
                operation: SpinalEnumCraft[LsuOperationType.type],
                width: SpinalEnumCraft[LsuAccessWidth.type]): UInt
}

trait LsuService {
  def setAddressTranslator(translator: LsuAddressTranslator): Unit
}

trait PcPayload[T <: Data] {
  /**
   * The payload's data type.
   */
  def dataType: HardType[T]

  /**
   * The payload's initial value. The first executed instruction will see this
   * value as the payload.
   */
  def initValue: T

  /**
   * Called when the given Stage causes PC to change. The return value should be
   * the payload's value for the target instruction.
   */
  def get(stage: Stage): T

  /**
   * Called to inject the payload in a Stage.
   */
  def set(stage: Stage, value: T)
}

trait JumpService {
  def jump(stage: Stage, target: UInt, isTrap: Boolean = false): Unit

  /**
   * Add a payload that travels through the pipeline along with PC.
   * A payload will typically be a pipeline register but PcPayload provides a
   * more abstract interface: whenever PC is updated, the payload is extracted
   * from the stage using PcPayload.get() and later injected into the first
   * stage of the target instruction using PcPayload.set().
   */
  def addPcPayload[T <: Data](pcPayload: PcPayload[T])

  type PcUpdateObserver = (Stage, UInt, UInt) => Unit

  /**
    * Register a callback to be called whenever the program counter is updated;
    * whether explicitly through a jump or implicitly after each instruction.
    * The parameters passed to `observer` are 1) the stage that caused the
    * update, 2) the current PC, and 3) the new PC. It is called on the context
    * of the top-level Pipeline.
    */
  def onPcUpdate(observer: PcUpdateObserver): Unit

  type JumpObserver = (Stage, UInt, UInt, Boolean) => Unit

  /**
   * Like onPcUpdate but only called for jumps.
   */
  def onJump(observer: JumpObserver): Unit
}

trait TrapService {
  def trap(stage: Stage, cause: TrapCause): Unit
  def hasTrapped(stage: Stage): Bool
  def hasException(stage: Stage): Bool
  def hasInterrupt(stage: Stage): Bool

  type TrapCommitCallback = (Stage, Bool, UInt) => Unit

  /**
   * The given callback will be called at the point where the logic to commit
   * traps is created. It is called during the build() phase which means the
   * callback should be registered during the setup() phase.
   */
  def onTrapCommit(cb: TrapCommitCallback)
}

trait Csr extends Area {
  def read(): UInt

  /**
    * Called for internal writes through the CsrIo interface.
    */
  def write(value: UInt): Unit = assert(false, "Cannot write RO CSR")

  /**
    * Called for software writes (CSR* instructions).
    */
  def swWrite(value: UInt): Unit = write(value)
}

class CsrIo(implicit config: Config) extends Bundle with IMasterSlave {
  val rdata, wdata = UInt(config.xlen bits)
  val write = Bool()

  def read(): UInt = rdata

  def write(value: UInt): Unit = {
    write := True
    wdata := value
  }

  override def asMaster(): Unit = {
    in(wdata, write)
    out(rdata)
  }

  override def asSlave(): Unit = {
    super.asSlave()

    write := False
    write.allowOverride
    wdata.assignDontCare()
    wdata.allowOverride
  }
}

trait CsrService {
  def registerCsr[T <: Csr](id: Int, reg: => T): T
  def getCsr(id: Int): CsrIo
}

class IrqIo extends Bundle with IMasterSlave {
  val update = Bool()
  val interruptPending = Bool()

  def init(): Unit = {
    if (isMasterInterface) {
      update := False
      interruptPending := False
    }
  }

  def postInterrupt(): Unit = {
    assert(isMasterInterface)

    update := True
    interruptPending := True
  }

  def clearInterrupt(): Unit = {
    assert(isMasterInterface)

    update := True
    interruptPending := False
  }

  override def asMaster(): Unit = {
    out(update, interruptPending)
  }
}

trait InterruptService {
  def getMachineTimerIrqIo: IrqIo
  def getExternalIrqIo: IrqIo
}

case class DataHazardInfo[T <: Data](registerType: SpinalEnumElement[RegisterType.type],
                                     rs1Data: PipelineData[T],
                                     rs2Data: PipelineData[T],
                                     rdData: PipelineData[T]
                                    )

trait DataHazardService {
  def addHazard[T <: Data](info: DataHazardInfo[T]): Unit

  /**
   * Stalls pipeline stages until the given hazard is resolved. More
   * specifically, conflicts() is called for each stage. Its first argument
   * is the stage itself, the second one is a sequence of all stages holding
   * non-retired earlier instructions. When there is a potential conflict (e.g.,
   * the stage reads a register that will be written by one of the later stages)
   * conflicts() should return True and the stage will be stalled.
   *
   * Note: this function should be called from Plugin.finish().
   */
  def resolveHazard(conflicts: (Stage, Seq[Stage]) => Bool)
}

trait FormalService {
  def lsuDefault(stage: Stage)
  def lsuOnLoad(stage: Stage, addr: UInt, rmask: Bits, rdata: UInt)
  def lsuOnStore(stage: Stage, addr: UInt, wmask: Bits, wdata: UInt)
  def lsuOnMisaligned(stage: Stage): Unit
}
